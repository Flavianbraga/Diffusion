```
                                    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣤⣴⣶⡆⠀⣶⣶⣦⣤⣤⣄⠀ ⢠⣾⣿⣦
                                    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡀⢰⣿⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⣿⣿⣿⡄⠘⢿⣿⠟
                                    ⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣧⠀⢻⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⣿⣿⣿⣿⠂⢠⣠⣤⣶⣦⡀
                                    ⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣇⠈⢿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⣿⣿⣿⠏⢀⣿⣿⣿⣿⣿⣿⣦⡀
                                    ⠀⠀⠀⠀⠀⠘⢿⣿⣿⣿⣿⣿⣿⣿⡆⠘⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⣿⣿⡏⠀⣾⣿⣿⣿⣿⣿⣿⡿⠋⢀
                                    ⠀⠀⠀⣴⣿⣦⡀⠙⢿⣿⣿⣿⣿⣿⣿⡄⠸⣿⣿⣿⣿⡇⠀⣿⣿⣿⣿⡟⠀⣼⣿⣿⣿⣿⣿⣿⠟⢀⣴⣿⣧
                                    ⠀⠀⣼⣿⣿⣿⣿⣦⡀⠙⢿⣿⣿⣿⣿⣷⡀⢹⣿⣿⣿⡇⠀⣿⣿⣿⡿⠁⣰⣿⣿⣿⣿⣿⠟⢁⣴⣿⣿⣿⣿⣧
                                    ⠀⣼⣿⣿⣿⣿⣿⣿⣿⣦⡀⠙⢿⣿⣿⣿⣧⠀⢻⣿⣿⡇⠀⣿⣿⣿⠃⢰⣿⣿⣿⣿⠟⢁⣴⣿⣿⣿⣿⣿⣿⣿⣧
                                    ⠀⠛⠿⢿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠙⢿⣿⣿⣇⠀⢿⣿⡇⠀⣿⣿⠇⢠⣿⣿⣿⠟⢁⣴⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠃
                                    ⣼⣶⣤⣄⡈⠙⠛⠿⣿⣿⣿⣿⣿⣦⡀⠙⢿⣿⡆⠈⠛⠃⠀⠛⠋⠀⣾⣿⠟⠁⣠⣾⣿⣿⣿⣿⡿⠿⠛⠉⣀⣠⣴⣶⡄
                                    ⣿⣿⣿⣿⣿⣿⣶⣤⣀⡉⠙⠻⢿⣿⣿⣦⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⢠⣾⣿⣿⠿⠛⠋⢁⣠⣴⣶⣿⣿⣿⣿⣿⣿⡀
                                    ⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣤⣀⠉⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠋⢁⣀⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧
                                    ⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠁⠀⣠⣶⣄
                                    ⠀⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⡄⠀ ⢻⣿⣿⡿
                                    ⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠓⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠂⠀⠈⠙⠋
                                    ⠀⠀⠘⣿⣿⣿⣿⣿⠿⠛⠋⢁⣠⣤⣶⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠋
                                    ⠀⠀⠀⠘⠟⠋⢉⣀⣤⣶⣿⣿⣿⣿⠟⠁⣠⣦⣄⡀⠀⠀⠀⠀⠀⠀⣤⣦⡈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠁
                                    ⠀⠀⠀⠀⠀⠘⢿⣿⣿⣿⣿⣿⠟⠁⣠⣾⣿⣿⣿⣿⣿⣶⣶⣾⣧⠀⢻⣿⣿⣦⡈⠻⣿⣿⣿⣿⡿⠟⠉
                                    ⠀⠀⠀⠀⠀⠀⠀⠙⠿⣿⡟⠁⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠈⠿⢿⣿⣿⣦⡈⠻⠛⠉
                                    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠺⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⢀⣤⣤⡈⠙⠋⠁
                                    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠛⠻⠿⠿⠿⠿⠿⠿⠇⠀ ⣿⣿⣿⡇
                                    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀   ⠈⠙⠋

                         /██   /██   /██   /██   /██████    /██████     /██████    /██      /██   /███████
                        | ██  | ██  | ███ | ██  |_  ██_/   /██__  ██   /██__  ██  | ███    /███  | ██__  ██
                        | ██  | ██  | ████| ██    | ██    | ██  \__/  | ██  \ ██  | ████  /████  | ██  \ ██
                        | ██  | ██  | ██ ██ ██    | ██    | ██        | ████████  | ██ ██/██ ██  | ███████/
                        | ██  | ██  | ██  ████    | ██    | ██        | ██__  ██  | ██  ███| ██  | ██____/
                        | ██  | ██  | ██\  ███    | ██    | ██    ██  | ██  | ██  | ██\  █ | ██  | ██
                        |  ██████/  | ██ \  ██   /██████  |  ██████/  | ██  | ██  | ██ \/  | ██  | ██
                         \______/   |__/  \__/  |______/   \______/   |__/  |__/  |__/     |__/  |__/
```
<p align="right"><b><sub>Version: 1.0.1</sub></b></p>

<p align="center"><b>Authors</b></p>
<p align="center">
Flavia Nogueira Braga<br>
Marcelle Spera<br>
Luís Fernando Mercier Franco<br></p>

# Self-diffision coefficients for confined fluids from molecular dynamic data
<p align="justify">
This algorithm was originally designed to calculate the self-diffusion coefficient of the components of a confined system in tree dimensions. In this work, the x and y directions will be called the parallel directtions and z is the perpeticular direction, since the wall of the system is in the z axys. The self-diffusion coefficients for the parallel components are calculated based on the work developed by Liu and colaborators (<a href="https://doi.org/10.1021/jp0375057">Liu et al., <b>J. Phys. Chem. B</b>, 108, 21, 6595–6602, 2004</a>). The perpendicular self-diffusion coefficient calculation, however, is based on the work developed by (<a href="https://doi.org/10.1021/acs.jctc.6b00653">Franco et al., <b> J. Chem. Theory Comput.</b>, 12, 11, 5247–5255, 2016</a>).
 
  
## Contents
* <a href="#disclaimer">1. Disclaimer</a>
* <a href="#language">2. Language</a>
* <a href="#building-and-compilation">3. Building and Compilation</a>
* <a href="#reporting-errors">4. Reporting Errors</a>
* <a href="#data-input">5. Data Input</a>
* <a href="#initial-configuration">6. Initial Configuration</a>
* <a href="#files-and-folders">7. Files and Folders</a>
* <a href="#running-the-code">8. Running the Code</a>

## Disclaimer
<p align="justify">
The authors make no warranties about the use of this software. The authors hold no liabilities for the use of this software. The authors do not 
 recommend the use of this software whatsoever. The algorithm is made freely available to clarify any details discussed in the paper.
 All information contained herein regarding any specific methodology does not constitute or imply its endorsement or recommendation by the authors.
</p>

## Language
<p align="justify">
The main program, subroutines and functions contain some explanatory comments and are mainly written in C language. 
</p>

## Building and Compilation
<p align="justify">
  

  For compilation, we have used the GNU Compiler Collection (GCC). See more information on GCC
 <a href="https://gcc.gnu.org/">here</a>. We tested the algorithm using some GCC versions: 9.3.0 in Ubuntu 20.04 LTS and 7.5.0 in Ubuntu 18.04 LTS.
</p>

<p align="justify">
We have built the code using the following command line:
</p>

```console
gcc diff.c -o out -lm
```

<p align="justify">


## Reporting Errors
<p align="justify">
If you spot an error in the program files and all other documentation, please submit an issue report using the <a href="https://github.com/Flavianbraga/Diffusion/issues">Issues</a> tab.
</p>

## Data Input 
<p align="justify">
Before running the code, the user should first prepare the files obtained from Molecular Dynamics (MD) simulation. The program used for MD simulations was GROMACS (version 2018.03 tested). Multiple files are obtained as outputs in the simulation. Here, the files will be refered by "name.type".
</p>
First, it is necessary to obtain the mean density of the molecules in function of the distance in z. This was done using GROMACS and the files .trr and .tpr, as shown by the following command line:
</p>

```console
gmx density -f prod_out.trr -s prod_out.tpr -o density.xvg -sl 1000 -d z

```
For further details on how to use gmx density the user is refered to the GROMACS <a href="https://manual.gromacs.org/documentation/2018/onlinehelp/gmx-density.html">documentation</a> for the topic.
</p>
Next, the trajectory in function of the timestep for each molecule must be obtained. Once again using GROMACS and files .trr and .tpr, as shown by the following command line:
</p>
  
```console
gmx trjconv -f prod_out.trr -s prod_out.tpr -pbc nojump -o out.gro

```
For further details on how to use gmx trjconv the user is refered to the GROMACS <a href="https://manual.gromacs.org/documentation/2018/onlinehelp/gmx-trjconv.html">documentation</a> for the topic.
</p>
In both cases, the molecule of interest to obtain the self-diffusion coefficent must be carefully specified. Only one type of molecule can be studied at a time. 
</p>
In order to obtain a compact file from the trajectories of the center of mass of the molecules, an additional code is needed: cmass.c. We have built the code using the following command line:
</p>

```console
gcc cmass.c -o out -lm
```
To run the code, the command line used was:

```console
./out 1 out.gro cmass.dat
```
Where the first argument refers to the number of pseudoatoms used to built the molecule. In the case of methane, using <a href="http://trappe.oit.umn.edu/">TraPPE forcefield</a>, for exemple, this number equals to one, while for ethane is two. The second argument, refers to the output of gmx trjconv while the third argument is the output of cmass.c.

It should be noticed that the number of steps in cmass.c must equal the ones used in the simulation (rever isso).

A folder named "results" should also be created inside the folder that the programs are running, as shown by the command line:
```console
mkdir results
```
An executable file with all the commands is also available: doit_diff.exe.
</p>

## Initial Configuration
</p>

## Files and Folders
<p align="justify">
After choosing the crystalline structure and inserting the values of <code>&kappa;&rho;*</code> and <code>&kappa;</code>, the program will organize the output files and directories.
 The program creates <b>6</b> parent directories in total. To better organize the output files, all directories (or subdirectories) contains a date folder, corresponding to the 
 starting date of the simulation (e.g. <code>20210101</code> means the simulation strated at January 1st, 2021).</p>

<p align="justify">
 The <code>Initial_Configuration/</code> directory and <code>OVITO/</code> subdirectory store the initial configuration file, consisting of position and orientation of   
 particles, as well as the molecular geometry.</p>

<p align="justify">
 The <code>Trajectories/</code> directory stores the trajectory file, consisting of the same properties of the initial configuration file. These properties are written out every 
 <code>n_save</code> cycles. <br><b>NOTE:</b><i> the algorithm creates this directory regardless the users' choice to write out the respective file.</i></p>

<p align="justify">
 The <code>Potential/</code> directory stores the potential energy of the perturbed system. This property is written out every <code>n_save</code> cycles. 
 The algorithm also creates one attractive range subfolder for every selected &lambda;. The calculated potential energy is then stored on each respective
 subfolder.</p>

<p align="justify">
 The <code>Ratio/</code> directory stores information on equilibration cycles (acceptance ratio, maximum displacement, and ratio threshold). This information is separated into 
 two subfolders: <code>Rotation/</code> for rotational movements and <code>Translation/</code> for translational movements.</p>

<p align="justify">
 The <code>Order_Parameter/</code> directory stores the nematic order parameter. This property is written out every <code>n_save</code> cycles.
</p>

<p align="justify">
 The <code>Perturbed_Coefficient/</code> directory stores the results generated by the block-average subroutine. Since these results are based on the potential energy of the perturbed system, they are also separated in subfolders based on the attractive range parameter. <br><b>NOTE:</b><i> the algorithm creates this directory regardless the users' choice to call the respective subroutine.</i></p>

<p align="justify">
The aforementioned folders are created by executing a shell command via an intrinsic function called <code>SYSTEM</code>. Please note that which shell is used to invoke the 
 command line is system-dependent and environment-dependent. Check this <a href="https://gcc.gnu.org/onlinedocs/gfortran/SYSTEM.html">link</a> for more information.</p>

<p align="justify">
File names are based on the information they hold, followed by the reduced number density and elongation parameters that were used to create them. Files with identical names
 are always overwritten. Thus, running simulations with the same <code>&kappa;&rho;*</code> and <code>&kappa;</code> at the same date will always overwrite existing data.</p>

## Running the Code
<p align="justify">
Because shell commands are executed during simulation and files are opened and written, we recommend Linux's users to run the compiled code with the <code>sudo</code> command
 below to avoid administrative issues.
</p>

```console
sudo ./main.out
```

<p align="justify">
After setting up the molecular structure and organizing folders and files, the algorithm will print out a user-friendly simulation summary. Here the user will be able to 
 review all important parameters (number of cycles, attractive range, reduced variables etc.) prior to the Monte Carlo simulation itself. After checking everything up, the
 user must press a <code>KEY</code> to continue the simulation.
</p>

<p align="justify">
The first simulation goal is to determine any possible molecular overlaps in the initial configuration. The overlap check is made by calculating the contact distance according 
 to the Hard Gaussian Overlap (HGO) model (<a href="https://doi.org/10.1063/1.1677837">Berne and Pechukas, <b>J. Chem. Phys.</b>, 56, 4213, 1972</a>). An overlap is detected 
 when the HGO contact distance is greater than or equal to the distance between the centers of mass of two molecular ellipsoids of revolution. If that happens, the simulation 
 is immediately interrupted. Otherwise, it proceeds to the Metropolis sampling algorithm (<a href="https://aip.scitation.org/doi/10.1063/1.1699114">Metropolis <i>et al.</i>, 
 <b>J. Chem. Phys.</b>, 21, 1087, 1953</a>).
</p>

<p align="justify">
During a sampling cycle, a particle is randomly selected according to a linear congruential generator (LCG). The LCG is a pseudorandom number generator that yields a sequence of
 randomized numbers from the uniform distribution over the range 0 &#8804; x < 1. Afterwards, a trial move is performed for the selected particle. Trial moves are divided 
 into two equiprobable events: a translational and a rotational displacement. Only one kind of molecular displacement can take place at a time in each cycle. If the 
 translational event is chosen, the selected particle will be randomly translated across the simulation box, limited to a maximum translational displacement (MTD). On the other 
 hand, if the rotational event is chosen, the selected particle will be randomly rotated around its center of mass, limited to a maximum rotational displacement (MRD). 
 Rotations are implemented via quaternions algebra. Read pages 106-111 of 
 <a href="https://oxford.universitypressscholarship.com/view/10.1093/oso/9780198803195.001.0001/oso-9780198803195">Allen and Tildesley (<b>Computer Simulation of Liquids</b>, 
 2nd edition, 2017)</a> for more details.
</p>

<p align="justify">
After randomly displacing a particle, the algorithm proceeds to the Metropolis' criterion, which can be simplified to a single molecular overlap check in the case of hard-core 
 geometries. Thus, the trial move is inspected to check any possible overlapping configurations. If overlap is detected, the trial move is immediately rejected and a new
 cycle begins. Otherwise, the trial move is accepted and the system is updated in terms of position and orientation of the selected particle and potential energy. 
 This energy is computed in accordance with the square-well (SW) potential.
</p>

<p align="justify">
The simulation is splitted into two phases: the equilibration phase and the production phase. During equilibration phase, the maximum displacements (MD) are either positively or 
 negatively adjusted by 5% of their current value. If the number of accepted moves divided by the   
 number of trial moves (acceptance ratio) is higher than a initially fixed threshold of 0.5, then the MDs are positively adjusted, and vice-versa. In some cases, the 
 equilibration phase 
 performs poorly. For instance, for low density systems composed of quasi-spherical particles (<i>i.e.</i>
 <code>&kappa; = 0.9</code>), most of the trial moves are accepted regarding rotational displacements. In that case, the sampling generally fails to generate overlapping
 configurations and thus the MRD will frequently undergo a positive adjustment. Eventually, the MRD skyrockets to impracticable values, leading to mathematical inaccuracies.
 Therefore, we decided to replace the fixed threshold by a "dynamic threshold". This dynamic threshold is arbitrarily modified everytime the MD values reach a limit. For MTD, 
 the upper limit is the maximum length of the simulation box, while the lower limit is <code>1 &#10799; 10&#8315;&#8309;</code>. For MRD, the upper limit is <code>&pi;</code> 
 (half-turn 
 condition), while the lower limit is <code>2 &#10799; 10&#8315;&#8308; / L</code>, where <i>L</i> is the largest ellipsoidal axis diameter. Except for the upper limit of the 
 MRD, the other limits are merely arbitrary. Hence, when the MDs reach the upper limit, the dynamic threshold increases, and when the MDs reach the lower limit, the dynamic 
 threshold decreases.<br><br>
 <b>NOTE:</b><i> Whenever the ratio threshold is modified, the simulation is reset to its initial values (configuration, energy, etc.), except for the current equilibration
 cycle. It is noteworthy to mention that we did not implement a simulation reset in our <a href="https://doi.org/10.1016/j.fluid.2021.113209">paper</a></i> (the final results are not significantly different).
</p>

<p align="justify">
During production phase, the potential energy of the perturbed system is computed and the nematic order parameter is calculated. The latter is calculated via a tensor 
 diagonalization 
 method (<a href="https://claudiozannoni.it/cambridge77_opdf.pdf">Zannoni, 1979. In: Luckhurst and Gray (eds.), <b>The Molecular Physics of Liquid Crystals</b>, 1979, pp. 
 51–83</a>).
</p>

<p align="justify">
After completing the Metropolis sampling, the algorithm evokes the block-average subroutine (depending on the user's choice). Read pages 281-287 of 
 <a href="https://oxford.universitypressscholarship.com/view/10.1093/oso/9780198803195.001.0001/oso-9780198803195">Allen and Tildesley (<b>Computer Simulation of Liquids</b>, 
 2nd edition, 2017)</a> for more details. This subroutine estimates the averages and 
 uncertainties of the first- and second-order perturbation coefficients, as well as the total Helmholtz free energy of the perturbed system.
 In the case of the Helmholtz free 
 energy, due to 
 high exponential terms that leads to computational inaccuracies in some machine's architectures, we applied a mathematical relation to replace an exponential sum by a more 
 practicable expression, saving processing time and avoiding overflow errors. Check this <a 
 href="https://aip.scitation.org/doi/suppl/10.1063/1.2165188/suppl_file/supplement.pdf">Supplementary Material (Abreu and Escobedo, <b>J. Chem. Phys.</b>, 124, 054116, 
 2006)</a> for more information.
</p>

<p align="justify">
At the end of the simulation, the program writes out a log file containing all simulation details. Later simulations will only append information to the log file instead of
 overwriting it.
</p>

---

“<i>With thermodynamics, one can calculate almost everything crudely; with kinetic theory, one can calculate fewer things, but more accurately; and with statistical mechanics, one can calculate almost nothing exactly.</i>” -- Eugene P. Wigner
